# Burrows-Wheeler
We'll implement the <em>Burrows–Wheeler data compression algorithm</em>. This revolutionary algorithm outcompresses <em>gzip</em> and <em>PKZIP</em>, is relatively easy to implement, and is not protected by any patents. It forms the basis of the Unix compression utility [bzip2](http://www.bzip.org/).
The Burrows–Wheeler data compression algorithm consists of three algorithmic components, which are applied in succession:

* <b>Burrows–Wheeler transform</b>. Given a typical English text file, transform it into a text file in which sequences of the same character occur near each other many times.
* <b>Move-to-front encoding</b>. Given a text file in which sequences of the same character occur near each other many times, convert it into a text file in which certain characters appear much more frequently than others.
* <b>Huffman compression</b>. Given a text file in which certain characters appear much more frequently than others, compress it by encoding frequently occurring characters with short codewords and infrequently occurring characters with long codewords.
Step 3 is the only one that compresses the message: it is particularly effective because Steps 1 and 2 produce a text file in which certain characters appear much more frequently than others. To expand a message, apply the inverse operations in reverse order: first apply the Huffman expansion, then the move-to-front decoding, and finally the inverse Burrows–Wheeler transform. Our task is to implement the Burrows–Wheeler and move-to-front components.

# Move-to-front
The main idea of <em>move-to-front</em> encoding is to maintain an ordered sequence of the characters in the alphabet by repeatedly reading a character from the input message; printing the position in the sequence in which that character appears; and moving that character to the front of the sequence. 
* <b>Move-to-front encoding</b>. Our task is to maintain an ordered sequence of the 256 extended ASCII characters. Initialize the sequence by making the ith character in the sequence equal to the ith extended ASCII character. Now, let's read each 8-bit character <code>c</code> from standard input, one at a time; output the 8-bit index in the sequence where </code>c appears; and move </code>c to the front.
* <b>Move-to-front decoding</b>. We have to initialize an ordered sequence of 256 characters, where extended ASCII character <em>i</em> appears <em>i</em>th in the sequence. Now, let's read each 8-bit character <em>i</em> (but treat it as an integer between 0 and 255) from standard input one at a time; write the <em>i</em>th character in the sequence; and move that character to the front.

# Circular suffix array
To efficiently implement the key component in the Burrows–Wheeler transform, we will use a fundamental data structure known as the <em>circular suffix array</em>, which describes the abstraction of a sorted array of the <em>n</em> circular suffixes of a string of length <em>n</em>. 

# Burrows–Wheeler transform
The goal of the Burrows–Wheeler transform is not to compress a message, but rather to transform it into a form that is more amenable for compression. The Burrows–Wheeler transform rearranges the characters in the input so that there are lots of clusters with repeated characters, but in such a way that it is still possible to recover the original input. It relies on the following intuition: if we see the letters <code>hen</code> in English text, then, most of the time, the letter preceding it is either <code>t</code> or <code>w</code>. If we could somehow group all such preceding letters together (mostly <code>t</code>’s and some <code>w</code>’s), then we would have a propitious opportunity for data compression.
* <b>Burrows–Wheeler transform</b>. The Burrows–Wheeler transform of a string <em>s</em> of length <em>n</em> is defined as follows: Consider the result of sorting the <em>n</em> circular suffixes of <em>s</em>. The Burrows–Wheeler transform is the last column in the sorted suffixes array <code>t[]</code>, preceded by the row number <code>first</code> in which the original string ends up. 
* <b>Burrows–Wheeler inverse transform</b>. If the jth original suffix (original string, shifted j characters to the left) is the ith row in the sorted order, we define <code>next[i]</code> to be the row in the sorted order where the <em>(j + 1)</em>st original suffix appears. For example, if first is the row in which the original input string appears, then <code>next[first]</code> is the row in the sorted order where the 1st original suffix (the original string left-shifted by 1) appears; <code>next[next[first]]</code> is the row in the sorted order where the <em>2nd</em> original suffix appears; <code>next[next[next[first]]]</code> is the row where the <em>3rd</em> original suffix appears; and so forth.
     1) <em>Constructing the next[] array from t[] and first</em>. The information contained in the Burrows–Wheeler transform suffices to reconstruct the <code>next[]</code> array, and, hence, the original message! Here’s how. It is easy to deduce a <code>next[]</code> value for a character that appears exactly once in the input string. For example, consider the suffix that starts with '<code>C</code>'. By inspecting the first column, it appears <em>8th</em> in the sorted order. The next original suffix after this one will have the character '<code>C</code>' as its last character. By inspecting the last column, the next original appears <em>5th</em> in the sorted order. Thus, <code>next[8] = 5</code>. Similarly, '<code>D</code>' and '<code>!</code>' each occur only once, so we can deduce that <code>next[9] = 2</code> and <code>next[0] = 3</code>. To resolve the ambiguity we apply the rule: <br><em> If sorted row i and j both start with the same character and i < j, then next[i] < next[j]. </em>
     3) <em>Inverting the message given t[], first, and the next[]</em> array. The input to the Burrows–Wheeler decoder is the last column <code>t[]</code> of the sorted suffixes along with <code>first</code>. From <code>t[]</code>, we can deduce the first column of the sorted suffixes because it consists of precisely the same characters, but in sorted order.


# Conclusion
Project involves my solution to the Burrows-Wheeler assignment. This problem is one of the assignments given in the online algorithm course of Princeton University. My work consists of MoveToFront.java, CircularSuffixArray.java and BurrowsWheeler.java. I used BinaryStdIn.java and BinaryStdOut.java, which are described in <em>Algorithms, 4th edition</em>, to read and write binary data. 


# References
* https://coursera.cs.princeton.edu/algs4/assignments/burrows/specification.php
* https://coursera.cs.princeton.edu/algs4/assignments/burrows/faq.php

